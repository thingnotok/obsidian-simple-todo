/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ToggleList
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// src/suggester.ts
var import_obsidian = require("obsidian");

// src/settings.ts
var DEFAULT_STATEGROUP = [
  [
    "- ",
    "- [ ] ",
    "- [x] || {tasks-today}",
    ""
  ],
  [
    "- [ ] ",
    "- [ ] #p1 ",
    "- [ ] #p2 ",
    "- [ ] #p3 "
  ],
  [
    "- ? ",
    "- ! ",
    "- ~ "
  ]
];
var DEFAULT_CMD = [
  {
    index: 0,
    pop: false,
    name: "Task",
    tmp_name: "Task",
    bindings: [0]
  },
  {
    index: 1,
    pop: false,
    name: "Task Priority",
    tmp_name: "Task Priority",
    bindings: [1]
  },
  {
    index: 2,
    pop: false,
    name: "Call out",
    tmp_name: "Call out",
    bindings: [2]
  },
  {
    index: 3,
    pop: false,
    name: "Task + Callout",
    tmp_name: "Task + Callout",
    bindings: [2, 0]
  }
];
var EMPTY_TOKEN = "{PARAGRAPH}";
var OLD_DATE = "{tasks-today}";
var PopState = class {
  constructor() {
    this.popon = false;
    this.hot = false;
    this.incr = 0;
  }
};
var Setup = class {
  constructor(text) {
    this.index = 0;
    this.update(text);
  }
  update(text = "") {
    this.all_states = text.replace(EMPTY_TOKEN, "");
    this.all_states = this.all_states.replace(OLD_DATE, "\u2705 {time:: YYYY-MM-DD}");
    this.states = this.all_states.split("\n");
    const ori_states = this.states;
    const tmp = /* @__PURE__ */ new Map();
    const new_tmp = /* @__PURE__ */ new Map();
    ori_states.forEach((os, idx) => tmp.set(os, idx));
    this.sorteds = ori_states.slice(0);
    this.sorteds = this.sorteds.sort((a, b) => b.length - a.length);
    this.sorteds.forEach((ss, idx) => new_tmp.set(idx, tmp.get(ss)));
    this.states_dict = new_tmp;
  }
};
var Command = class {
  constructor(cmd) {
    this.index = cmd.index || 0;
    this.name = cmd.name || "";
    this.tmp_name = this.name;
    this.bindings = cmd.bindings || Array();
    this.isPopOver = cmd.isPopOver || false;
  }
};
var ToggleListSettings = class {
  constructor(fromFile) {
    var _a;
    this.pop_state = new PopState();
    this.plot = false;
    this.cmd_list = fromFile == null ? void 0 : fromFile.cmd_list.map((cmd) => new Command(cmd));
    this.setup_list = (_a = fromFile == null ? void 0 : fromFile.setup_list) == null ? void 0 : _a.map((setup) => new Setup((setup == null ? void 0 : setup.all_states) || ""));
    if (!this.setup_list) {
      this.reset_setup_list();
    }
    if (!this.cmd_list) {
      this.reset_cmd_list();
    }
    this.validate();
  }
  addStateGroup() {
    const chosen = DEFAULT_STATEGROUP.at(Math.floor(Math.random() * DEFAULT_STATEGROUP.length)) || [];
    this.setup_list.push(new Setup(chosen.join("\n")));
  }
  validate() {
    this.cleanSetupList();
    this.cleanCmdList();
  }
  reset_setup_list() {
    this.setup_list = DEFAULT_STATEGROUP.map((setup) => {
      return new Setup(setup.join("\n"));
    });
  }
  reset_cmd_list() {
    this.cmd_list = DEFAULT_CMD.map((cmd) => {
      return new Command(cmd);
    });
  }
  reset() {
    this.reset_setup_list();
    this.reset_cmd_list();
    this.validate();
  }
  cleanSetupList() {
    this.setup_list = this.setup_list.map((setup) => {
      const states = setup.states;
      const states_ary = [...new Set(states)];
      return new Setup(states_ary.join("\n"));
    });
    this.setup_list.forEach((setup, idx) => setup.index = idx);
  }
  cleanCmdList() {
    this.cmd_list.forEach((cmd) => {
      cmd.bindings = cmd.bindings.filter((b) => b < this.setup_list.length);
    });
    this.cmd_list = this.cmd_list.filter((cmd) => cmd.bindings.length > 0);
  }
  cleanCmdListAfterSetupRemoved(removedIdx) {
    this.cmd_list.forEach((cmd) => {
      const nbinding = cmd.bindings.map(function(b) {
        return b > removedIdx ? b - 1 : b == removedIdx ? -1 : b;
      });
      cmd.bindings = nbinding.filter((b) => b >= 0);
    });
  }
  removeSetup(setup) {
    const index = setup.index;
    this.cleanCmdListAfterSetupRemoved(index);
    this.setup_list.splice(index, 1)[0];
    this.validate();
  }
};

// src/tlAction.ts
var timeFormats = [
  { rule: /\\{time:: YYYY-MM-DD hh:mm\\}/, pattern: "\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}" },
  { rule: /\\{time:: YYYY-MM-DD\\}/, pattern: "\\d{4}-\\d{2}-\\d{2}" },
  { rule: /\\{time:: hh:mm:ss\\}/, pattern: "\\d{2}:\\d{2}:\\d{2}" },
  { rule: /\\{time:: hh:mm\\}/, pattern: "\\d{2}:\\d{2}" },
  { rule: /\\{time:: YYYY-MM\\}/, pattern: "\\d{4}-\\d{2}" },
  { rule: /\\{time:: MM-DD\\}/, pattern: "\\d{2}-\\d{2}" },
  { rule: /\\{time:: YYYY\\}/, pattern: "\\d{4}" },
  { rule: /\\{time:: MM\\}/, pattern: "\\d{2}" },
  { rule: /\\{time:: DD\\}/, pattern: "\\d{2}" },
  { rule: /\\{time:: hh\\}/, pattern: "\\d{2}" },
  { rule: /\\{time:: mm\\}/, pattern: "\\d{2}" },
  { rule: /\\{time:: ss\\}/, pattern: "\\d{2}" }
];
function formatDate(format, date) {
  const day = date.getDate();
  const month = date.getMonth() + 1;
  const year = date.getFullYear();
  const hours = date.getHours();
  const minutes = date.getMinutes();
  const seconds = date.getSeconds();
  const replacements = {
    "YYYY": year.toString(),
    "YY": String(year).slice(-2),
    "MM": month.toString().padStart(2, "0"),
    "DD": day.toString().padStart(2, "0"),
    "hh": hours.toString().padStart(2, "0"),
    "mm": minutes.toString().padStart(2, "0"),
    "ss": seconds.toString().padStart(2, "0"),
    "M": month.toString(),
    "D": day.toString(),
    "h": hours.toString(),
    "m": minutes.toString(),
    "s": seconds.toString()
  };
  let formattedDate = format;
  for (let key in replacements) {
    formattedDate = formattedDate.replace(key, replacements[key]);
  }
  return formattedDate;
}
function setupCursor(cursor, offset, origin_set, new_set) {
  const x0 = (origin_set == null ? void 0 : origin_set.x) || 0;
  const y0 = (origin_set == null ? void 0 : origin_set.y) || 0;
  const x1 = (new_set == null ? void 0 : new_set.x) || 0;
  const y1 = (new_set == null ? void 0 : new_set.y) || 0;
  const a = (origin_set == null ? void 0 : origin_set.a) || 0;
  const z = (origin_set == null ? void 0 : origin_set.z) || 0;
  if (cursor.ch <= x0)
    cursor.ch = x1;
  else if (cursor.ch <= x0 + a)
    cursor.ch = cursor.ch + offset;
  else if (cursor.ch > x0 + a && cursor.ch <= x0 + a + y0)
    cursor.ch = x1 + a;
  else
    cursor.ch = x1 + a + y1 + z;
  return cursor;
}
function triggerSuggestionEditorByToggleState(editor, cmd, settings, direction) {
  const cursor = editor.getCursor();
  const line = editor.getLine(cursor.line);
  for (let i = 0; i < cmd.bindings.length; i++) {
    const setup = settings.setup_list[cmd.bindings[i]];
    const r = match_sg(line, setup);
    if (r.success) {
      const stateIdx = r.offset;
      const result = processOneLine(line, setup, -1, direction);
      editor.setLine(cursor.line, result.content);
      const new_cursor = setupCursor(cursor, result.offset, result.origin_set, result.new_set);
      editor.setCursor(new_cursor.line, new_cursor.ch);
      if (cmd.isPopOver)
        settings.pop_state.hot = true;
      settings.pop_context = { setup, stateIdx, direction };
      return;
    }
  }
}
function popAction(editor, cmd, settings, direction, app) {
  const selections = editor.listSelections()[0];
  const isMultiLine = selections.anchor.line != selections.head.line;
  if (!isMultiLine) {
    return triggerSuggestionEditorByToggleState(editor, cmd, settings, direction);
  } else {
    return toggleAction(editor, settings.setup_list, cmd.bindings, direction);
  }
}
function renderEmptyLine(text) {
  const emptyline = EMPTY_TOKEN + "\n";
  const emptyline_last = "\n" + EMPTY_TOKEN;
  let result = text.replace(/(^\n)/gm, emptyline);
  result = result.replace(/\n$/gm, emptyline_last);
  if (result == "")
    result = EMPTY_TOKEN;
  return result;
}
function getFormatTime(time_format) {
  const now = new Date(new Date().getTime());
  const convertTime = formatDate(time_format, now) || "";
  return convertTime;
}
function applyTimeFormats(text) {
  const regex = /\{(time::.*)\}/;
  const ff = text.match(regex);
  const found = ff || [];
  let suffix = text;
  if (found.length > 0) {
    const tag = found[1];
    const tag_ = tag.split(":: ");
    const time_format = tag_[1];
    const convertTime = getFormatTime(time_format);
    suffix = suffix.replace("{" + found[1] + "}", convertTime);
  }
  return suffix;
}
function ChangeState(text, prev, next) {
  const pre = applyTimeFormats(next[0]) || "";
  const sur = applyTimeFormats(next[1]) || "";
  return pre + text + sur;
}
function getRegExp(text) {
  let t = text || "";
  t = t.replace(/([\.\+\*\?\^\$\(\)\[\]\{\}\|\\])/g, "\\$1");
  for (let i = 0; i < timeFormats.length; i++)
    t = t.replace(timeFormats[i].rule, timeFormats[i].pattern);
  return t;
}
function getCurrentState(text, states) {
  for (let i = 0; i < states.length; i++) {
    const s = states[i].split("||");
    const prefix = getRegExp(s[0]);
    const suffix = getRegExp(s[1]);
    let state_regex = new RegExp(`^(\\s*)${prefix}(.*)${suffix}$`);
    const result = text.match(state_regex) || [];
    if (result.length > 0) {
      return { sorted_idx: i, raw: result[2], idents: result[1] };
    }
  }
  return { sorted_idx: -1, raw: "" };
}
function separatePreSur(state) {
  const strings = state.split("||");
  strings.push("");
  return strings;
}
function roundAdd(a, b, low, high) {
  let result = a + b;
  if (result == high)
    result = low;
  if (result < low)
    result = high - 1;
  return result;
}
function getBlkID(line) {
  const blockIdRegex = /( \^[a-zA-Z0-9-]+)/;
  const blockIdMatch = line.match(blockIdRegex);
  const blockId = blockIdMatch ? blockIdMatch[0] : "";
  const lineWithoutBlockId = line.replace(blockIdRegex, "");
  return { blockId, lineWithoutBlockId };
}
function processOneLine(text, setup, specifyIdx, direction) {
  const { blockId, lineWithoutBlockId } = getBlkID(text);
  const cur_match = getCurrentState(lineWithoutBlockId, setup.sorteds);
  if (cur_match.sorted_idx < 0) {
    return { success: false, content: lineWithoutBlockId, offset: 0, origin_set: { x: 0, a: 0, y: 0, z: 0 }, new_set: { x: 0, a: 0, y: 0, z: 0 } };
  }
  const cur_idx = setup.states_dict.get(cur_match.sorted_idx) || 0;
  let next_idx = specifyIdx;
  if (specifyIdx < 0)
    next_idx = roundAdd(cur_idx, direction, 0, setup.states.length);
  const cur_pair = separatePreSur(setup.states[cur_idx]);
  const next_pair = separatePreSur(setup.states[next_idx]);
  let new_text = cur_match.idents + ChangeState(cur_match.raw, cur_pair, next_pair);
  let next_txt = next_pair[0];
  let cur_txt = cur_pair[0];
  next_txt = applyTimeFormats(next_txt);
  cur_txt = applyTimeFormats(cur_txt);
  new_text = new_text + blockId;
  const offset = next_txt.length - cur_txt.length;
  let x0 = applyTimeFormats(cur_pair[0]).length || 0;
  let y0 = applyTimeFormats(cur_pair[1]).length || 0;
  let z = blockId.length || 0;
  let x1 = applyTimeFormats(next_pair[0]).length || 0;
  let y1 = applyTimeFormats(next_pair[1]).length || 0;
  let A = cur_match.raw.length || 0;
  return {
    success: true,
    content: new_text,
    offset,
    origin_set: { x: x0, a: A, y: y0, z },
    new_set: { x: x1, a: A, y: y1, z }
  };
}
function match_sg(text, setup) {
  const cur_match = getCurrentState(text, setup.sorteds);
  if (cur_match.sorted_idx < 0) {
    return { success: false, content: text, offset: 0 };
  }
  const cur_idx = setup.states_dict.get(cur_match.sorted_idx) || 0;
  const cur_pair = separatePreSur(setup.states[cur_idx]);
  return { success: true, content: cur_pair[0], offset: cur_idx };
}
function toggleAction(editor, sg_list, bindings, direction) {
  let selection = editor.listSelections()[0];
  let cursor = editor.getCursor();
  let set_cur = false;
  if (selection.head.ch == selection.anchor.ch && selection.head.line == selection.anchor.line)
    set_cur = true;
  const head = selection.head.line;
  const anchor = selection.anchor.line;
  let start_line = head;
  let end_line = anchor;
  if (start_line > end_line) {
    start_line = anchor;
    end_line = head;
  }
  for (let i = start_line; i <= end_line; i++) {
    const origin = editor.getLine(i);
    let r = { success: false, content: origin, offset: 0, origin_set: { x: 0, y: 0, a: 0, z: 0 }, new_set: { x: 0, y: 0, a: 0, z: 0 } };
    for (let i2 = 0; i2 < bindings.length; i2++) {
      r = processOneLine(origin, sg_list[bindings[i2]], -1, direction);
      if (r.success)
        break;
    }
    editor.setLine(i, r.content);
    if (i == cursor.line) {
      cursor = setupCursor(cursor, r.offset, r.origin_set, r.new_set);
    }
    if (i == head) {
      const head_cursor = setupCursor(selection.head, r.offset, r.origin_set, r.new_set);
      selection.head = head_cursor;
    }
    if (i == anchor) {
      const anchor_cursor = setupCursor(selection.anchor, r.offset, r.origin_set, r.new_set);
      selection.anchor = anchor_cursor;
    }
  }
  editor.setSelection(selection.anchor, selection.head);
  if (set_cur)
    editor.setCursor(cursor);
}

// src/suggester.ts
function buildSuggestions(line_num, line, idx, setup, direction) {
  let suggestions = [];
  const N = setup.states.length;
  const nidx = (idx + direction + N) % N;
  const final = [...Array(N).keys()].map((i) => (i * direction + nidx + N) % N);
  for (let i = 0; i < N - 1; i++) {
    const curIdx = final[i];
    suggestions.push({
      displayText: setup.states[curIdx],
      appendText: line,
      insertAt: line_num,
      insertSkip: curIdx
    });
  }
  return suggestions;
}
var EditorSuggestor = class extends import_obsidian.EditorSuggest {
  constructor(app, settings) {
    super(app);
    this.settings = settings;
    this.popw = settings.pop_state;
  }
  onTrigger(cursor, editor, _file) {
    if (!this.popw.hot) {
      this.popw.popon = false;
    } else {
      this.popw.hot = false;
      const context = this.settings.pop_context;
      const line = editor.getLine(cursor.line);
      return { start: cursor, end: { line: cursor.line, ch: context.stateIdx }, query: line };
    }
    return null;
  }
  getSuggestions(context) {
    const line = context.query;
    const line_idx = context.start.line;
    let state_idx = context.end.ch;
    const pop_context = this.settings.pop_context;
    const N = pop_context.setup.states.length;
    this.popw.incr = 0;
    state_idx += (N + pop_context.direction) % N;
    const suggestions = buildSuggestions(line_idx, line, state_idx, pop_context.setup, pop_context.direction);
    const suggestionsWithContext = [];
    for (const suggestion of suggestions)
      suggestionsWithContext.push({ ...suggestion, context });
    this.popw.popon = true;
    return suggestionsWithContext;
  }
  renderSuggestion(value, el) {
    el.setText(value.displayText);
  }
  selectSuggestion(value, _evt) {
    const editor = value.context.editor;
    const line = value.appendText;
    const cur_steup = this.settings.pop_context.setup;
    const r = processOneLine(line, cur_steup, value.insertSkip || 0, 1);
    const line_idx = value.insertAt || 0;
    const cursor = editor.getCursor();
    editor.setLine(line_idx, r.content);
    const ch = cursor.ch + r.offset > r.content.length ? r.content.length : cursor.ch + r.offset;
    editor.setCursor(line_idx, ch);
    this.popw.popon = false;
    this.popw.incr = 0;
  }
};

// src/UI.ts
var import_obsidian2 = require("obsidian");
function genSGSection(tab) {
  const plugin = tab.plugin;
  const settings = tab.plugin.settings;
  tab.containerEl.createEl("h3", { text: "Setup The States to Toggle" });
  const setup_list = settings.setup_list;
  settings.setup_list.forEach((setup) => {
    addSetupUI(tab, setup);
  });
  new import_obsidian2.Setting(tab.containerEl).addButton((cb) => {
    cb.setButtonText("+ State Group").setCta().onClick(() => {
      settings.addStateGroup();
      plugin.checkNreload();
    });
  }).addButton((cb) => {
    cb.setIcon("checkmark");
    cb.setCta();
    cb.onClick(() => {
      plugin.checkNreload();
    });
  });
}
function addCmdUI(tab, cmd, cmdIdx) {
  const cmd_list = tab.plugin.settings.cmd_list;
  const settings = tab.plugin.settings;
  const plugin = tab.plugin;
  let desc = `${cmd.name}: ${cmd.isPopOver ? "popover" : ""} binding: ${cmd.bindings}`;
  const cmd_section = new import_obsidian2.Setting(tab.containerEl).setName(`${cmd.name}`).setDesc(desc).addToggle((cb) => {
    cb.setValue(cmd.isPopOver);
    cb.onChange((value) => {
      cmd.isPopOver = value;
      plugin.checkNreload();
    });
  }).addText((cb) => {
    cb.setValue(cmd.name);
    cb.setPlaceholder("Command Name");
    cb.onChange((value) => {
      cmd.name = value;
    });
  }).addText((cb) => {
    cb.setValue(cmd.bindings.map((x) => x.toString()).join(", "));
    cb.setPlaceholder("Indices of State Groups: 0, 1, 2");
    cb.onChange((value) => {
      cmd.bindings = value.split(",").map((x) => parseInt(x, 10));
    });
  }).addButton((cb) => {
    cb.setIcon("cross").setTooltip("Delete");
    cb.setCta();
    cb.onClick(() => {
      cmd_list.splice(cmdIdx, 1);
      plugin.checkNreload();
    });
  });
}
function genCMDSection(tab) {
  tab.containerEl.createEl("h3", { text: "Bind the Commands with State Groups" });
  tab.containerEl.createEl("p", { text: "Order of bindings matters if two SG share the same states" });
  tab.containerEl.createEl("p", { text: "Turn on suggestion will show a suggestion window to access all states" });
  tab.containerEl.createEl("p", { text: `[Suggection] [Name] [Binding SG]` });
  const cmd_list = tab.plugin.settings.cmd_list;
  for (let i = 0; i < cmd_list.length; i++) {
    addCmdUI(tab, cmd_list[i], i);
  }
  new import_obsidian2.Setting(tab.containerEl).addButton((cb) => {
    cb.setButtonText("+ Command");
    cb.setCta();
    cb.onClick(() => {
      const name = `Command ${cmd_list.length}`;
      if (tab.plugin.settings.setup_list.length > 0) {
        cmd_list.push(new Command({ index: cmd_list.length, name, bindings: [0] }));
        tab.plugin.checkNreload();
      } else {
        tab.plugin.sendNotify("No State Groups to bind");
      }
    });
  }).addButton((cb) => {
    cb.setButtonText("Click to validate");
    cb.setIcon("checkmark");
    cb.setCta();
    cb.onClick(() => {
      tab.plugin.checkNreload();
    });
  });
}
function genMISCSection(tab) {
  const cmd_list = tab.plugin.settings.cmd_list;
  const settings = tab.plugin.settings;
  const plugin = tab.plugin;
  const other = new import_obsidian2.Setting(tab.containerEl);
  other.addButton((cb) => {
    cb.setButtonText("\u{1F525} Hotkeys").setCta().onClick(() => {
      this.app.setting.openTabById("hotkeys").setQuery("ToggleList");
    });
  });
  other.addButton((cb) => {
    cb.setButtonText("\u21BB Reset").setCta().onClick(async () => {
      const stamp = new Date().toISOString();
      await this.app.vault.writeConfigJson(`plugins/obsidian-toggle-list/backup-${stamp}`, settings);
      new import_obsidian2.Notice(`ToggleList: Original config is saved in plugins/obsidian-toggle-list/backup-${stamp}.json`);
      plugin.reset();
      plugin.reloadSettingUI();
    });
  });
}
async function genDiagramSection(tab) {
  const other = new import_obsidian2.Setting(tab.containerEl);
  if (tab.plugin.settings.cmd_list.length > 0) {
    const svg_container = tab.containerEl.createEl("div");
  } else {
    tab.containerEl.createEl("h2", { text: "Add at least one State Group and one Command to draw State Diagram" });
  }
}
function genExplanation(tab) {
  const exp = tab.containerEl.createEl("div", { cls: "togglelist_div" });
  exp.innerHTML = `<button class="togglelist_btn">
		<a href="https://github.com/thingnotok/obsidian-toggle-list">README</a>
		</button>`;
}
function addSetupUI(container, setup) {
  const plugin = container.plugin;
  const sg_ui = new import_obsidian2.Setting(container.containerEl).addButton((cb) => {
    cb.setIcon("cross").setTooltip("Delete");
    cb.setCta().setCta().onClick(() => {
      plugin.settings.removeSetup(setup);
      plugin.checkNreload();
    });
  });
  const renderedText = renderEmptyLine(setup.all_states);
  sg_ui.setName("State Group: " + setup.index.toString());
  const ta = sg_ui.addTextArea((text) => {
    text.setValue(renderedText);
    text.onChange(async (text_value) => {
      setup.update(text_value);
    });
    text.inputEl.setAttribute("rows", setup.states.length.toFixed());
    text.inputEl.setAttribute("cols", "25");
    text.inputEl.style.cssText = "resize: none";
  });
}
var ToggleListSettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  addSettingUI() {
    genSGSection(this);
    genCMDSection(this);
    genMISCSection(this);
    genDiagramSection(this);
    genExplanation(this);
  }
  display() {
    this.containerEl.empty();
    this.addSettingUI();
  }
};

// src/main.ts
function deleteObsidianCommand(app, commandId) {
  if (app.commands.findCommand(commandId)) {
    delete app.commands.commands[commandId];
    delete app.commands.editorCommands[commandId];
  }
}
var ToggleList = class extends import_obsidian3.Plugin {
  async onload() {
    await this.loadSettings();
    this.tab = new ToggleListSettingTab(this.app, this);
    this.addSettingTab(this.tab);
    this.registerActions();
    this.registerEditorSuggest(new EditorSuggestor(this.app, this.settings));
    this.cleanHotkeys();
  }
  async loadSettings() {
    const settings = await this.loadData();
    this.settings = new ToggleListSettings(settings);
    this.saveSettings();
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  cleanHotkeys() {
    const customKeys = this.app.hotkeyManager.customKeys;
    let cc = Object.keys(customKeys);
    for (let i = 0; i < cc.length; i++) {
      if (cc[i].slice(0, 20) == "obsidian-toggle-list") {
        if (cc[i].slice(-4) != "Prev" && cc[i].slice(-4) != "Next") {
          if (cc[i].slice(-4) == "-POP") {
            const name = cc[i].slice(0, -3) + "Next";
            customKeys[name] = customKeys[cc[i]];
          }
          delete customKeys[cc[i]];
        }
      }
    }
    const cmds = this.settings.cmd_list;
    cc = Object.keys(customKeys);
    for (let i = 0; i < cc.length; i++) {
      const name = cc[i].slice(21, -5);
      if (!cmds.find((e) => e.name == name))
        delete customKeys[cc[i]];
    }
  }
  unregisterActions() {
    this.settings.registedCmdName.forEach((cmd) => this.unregistAction(`obsidian-toggle-list:${cmd}`));
    this.settings.registedCmdName = [];
  }
  unregistAction(cmd) {
    deleteObsidianCommand(this.app, cmd);
  }
  registerActions() {
    const sg_list = this.settings.setup_list;
    const reg = Array();
    this.settings.cmd_list.forEach((cmd) => {
      this.registerAction(cmd, sg_list);
      reg.push(`${cmd.name}-Next`);
      reg.push(`${cmd.name}-Prev`);
    });
    this.settings.registedCmdName = reg;
  }
  registerAction(cmd, sg_list) {
    const n_name = `${cmd.name}-Next`;
    const p_name = `${cmd.name}-Prev`;
    this.addCommand({
      id: n_name,
      name: n_name,
      icon: "right-arrow",
      editorCallback: (editor, view) => {
        popAction(editor, cmd, this.settings, 1, this.app);
      }
    });
    this.addCommand({
      id: p_name,
      name: p_name,
      icon: "left-arrow",
      editorCallback: (editor, view) => {
        popAction(editor, cmd, this.settings, -1, this.app);
      }
    });
  }
  checkNreload() {
    this.settings.validate();
    this.unregisterActions();
    this.registerActions();
    this.saveSettings();
    this.reloadSettingUI();
  }
  reloadSettingUI() {
    this.tab.display();
  }
  reset() {
    this.unregisterActions();
    this.settings.reset();
  }
  sendNotify(text) {
    new import_obsidian3.Notice(text);
  }
};
